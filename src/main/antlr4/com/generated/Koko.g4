grammar Koko;

prog: expr* ;
expr: function ;
function: functionHeader NEWLINE functionBody NEWLINE* ;
functionHeader: IDENTIFIER argList SPACE INT_TYPE ;
argList: LEFT_PAREN argDeclaration* RIGHT_PAREN ;
argDeclaration: INT_TYPE SPACE IDENTIFIER ;
functionBody: (TAB (intDeclaration|ifStatement) NEWLINE)* TAB returnStatment ;
ifStatement: IF SPACE ifExpr NEWLINE TAB TAB returnStatment ;
ifExpr: boolExpr ;
boolExpr: IDENTIFIER SPACE GT SPACE INT_LITERAL ;
returnStatment: RETURN SPACE returnValue ;
returnValue: intLiteral | functionCall | identifier | addStatement ;
functionCall: IDENTIFIER LEFT_PAREN functionCallArgs RIGHT_PAREN ;
functionCallArgs: (listLiteral|intLiteral)* ;
intDeclaration: INT_TYPE SPACE IDENTIFIER SPACE EQUAL SPACE INT_LITERAL ;
addStatement: INT_LITERAL SPACE PLUS SPACE INT_LITERAL ;
listLiteral: LEFT_BRACKET RIGHT_BRACKET ;
intLiteral: INT_LITERAL ;
identifier: IDENTIFIER ;

COMMENT: '#' TAB* ~( '\n' )* '\n' -> skip;
SPACE: ' ' ;
IF: 'if' ;
GT: '>' ;
RETURN: 'ret' ;
INT_TYPE: 'int' ;
INT_LITERAL: [0-9]+ ;
IDENTIFIER: [a-z]+[0-9]* ;
LEFT_PAREN: '(' ;
RIGHT_PAREN: ')' ;
LEFT_BRACKET: '[' ;
RIGHT_BRACKET: ']' ;
DOT: '.' ;
TAB: '\t' | '    ' ;
NEWLINE: '\n' ;
EQUAL: '=' ;
PLUS: '+' ;
